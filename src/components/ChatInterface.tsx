'use client';

import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';

interface Message {
  role: 'user' | 'assistant';
  content: string;
}

interface PersonaMeta {
  id: string;
  name: string;
  title: string;
  icon?: string;
}

interface ChatInterfaceProps {
  personaId: string;
  mode: 'practice' | 'feedback';
  onModeChange: (mode: 'practice' | 'feedback') => void;
}

export function ChatInterface({ personaId, mode, onModeChange }: ChatInterfaceProps) {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [persona, setPersona] = useState<PersonaMeta | null>(null);

  // Fetch persona metadata
  useEffect(() => {
    fetch('/api/personas')
      .then((res) => res.json())
      .then((data: PersonaMeta[]) => {
        const found = data.find((p) => p.id === personaId);
        setPersona(found || null);
      })
      .catch(() => {});
  }, [personaId]);

  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInput(e.target.value);
  };

  const sendMessage = async (messagesToSend: Message[], currentMode: 'practice' | 'feedback') => {
    setIsLoading(true);
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          messages: messagesToSend,
          personaId,
          mode: currentMode,
        }),
      });

      if (!response.ok) throw new Error('API request failed');

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let assistantMessage = '';

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          assistantMessage += chunk;

          setMessages((prev) => {
            const newMessages = [...prev];
            const lastMessage = newMessages[newMessages.length - 1];
            if (lastMessage?.role === 'assistant') {
              lastMessage.content = assistantMessage;
              return newMessages;
            } else {
              return [...prev, { role: 'assistant', content: assistantMessage }];
            }
          });
        }
      }
    } catch (error) {
      console.error('Chat error:', error);
      setMessages((prev) => [
        ...prev,
        { role: 'assistant', content: 'Sorry, there was an error. Please try again.' },
      ]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;

    const userMessage: Message = { role: 'user', content: input };
    const updatedMessages = [...messages, userMessage];
    setMessages(updatedMessages);
    setInput('');

    await sendMessage(updatedMessages, mode);
  };

  const handleGetFeedback = () => {
    onModeChange('feedback');
    const feedbackPrompt = 'How did I do? Give me detailed feedback on my answers.';
    const userMessage: Message = { role: 'user', content: feedbackPrompt };
    const updatedMessages = [...messages, userMessage];
    setMessages(updatedMessages);
    setInput('');
    sendMessage(updatedMessages, 'feedback');
  };

  const exportTranscript = () => {
    const displayName = persona?.name || personaId;
    const displayTitle = persona?.title || '';
    const displayIcon = persona?.icon || 'ðŸ‘¤';
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = `Interview_${displayName.replace(/\s+/g, '_')}_${timestamp}.md`;

    let markdown = `# AI Interview Coach Session\n\n`;
    markdown += `**Date:** ${new Date().toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })}\n`;
    markdown += `**Interviewer:** ${displayName} (${displayTitle})\n`;
    markdown += `**Mode:** ${mode === 'practice' ? 'Practice' : 'Feedback'}\n\n`;
    markdown += `---\n\n`;

    messages.forEach((msg) => {
      if (msg.role === 'user') {
        markdown += `## Your Answer\n\n${msg.content}\n\n`;
      } else {
        markdown += `## ${displayIcon} ${displayName}\n\n${msg.content}\n\n`;
      }
    });

    markdown += `---\n\n`;
    markdown += `*Generated by AI Interview Coach*\n`;

    return { markdown, filename };
  };

  const handleExport = () => {
    try {
      const { markdown, filename } = exportTranscript();
      const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      setTimeout(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }, 100);
    } catch (error) {
      console.error('Export failed:', error);
      alert('Failed to export transcript. Please try again.');
    }
  };

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Trigger initial question when persona is selected
  useEffect(() => {
    if (messages.length === 0 && !isLoading) {
      sendMessage([{ role: 'user', content: 'Hello' }], 'practice');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [personaId]);

  return (
    <div className="flex flex-col h-[calc(100vh-200px)] max-h-[800px]">
      {/* Mode indicator */}
      <div className="mb-4 flex items-center justify-between">
        <div className="flex items-center gap-2">
          {mode === 'practice' ? (
            <Badge>Practice Mode</Badge>
          ) : (
            <Badge variant="secondary">Feedback Mode</Badge>
          )}
        </div>
        {mode === 'practice' && messages.length <= 2 && messages.length > 0 && (
          <p className="text-xs text-gray-500">
            &quot;Get Feedback&quot; button will appear after a few exchanges
          </p>
        )}
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto space-y-4 mb-4 p-4 bg-gray-50 rounded-lg">
        {messages.length === 0 && !isLoading && (
          <div className="text-center text-gray-500 mt-8">
            <p>Loading interviewer...</p>
          </div>
        )}

        {messages.map((msg, idx) => (
          <div
            key={idx}
            className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
          >
            <Card
              className={`max-w-[80%] p-4 ${
                msg.role === 'user' ? 'bg-blue-50 border-blue-200' : 'bg-white'
              }`}
            >
              <div className="prose prose-sm max-w-none">
                <ReactMarkdown>{msg.content}</ReactMarkdown>
              </div>
            </Card>
          </div>
        ))}

        {isLoading && (
          <div className="flex justify-start">
            <Card className="max-w-[80%] p-4 bg-white">
              <div className="text-gray-500 animate-pulse">Thinking...</div>
            </Card>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <form onSubmit={handleSubmit} className="flex flex-col gap-2">
        <Textarea
          value={input}
          onChange={handleInputChange}
          placeholder="Type your answer..."
          className="min-h-[100px]"
          disabled={isLoading}
          onKeyDown={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              handleSubmit(e as unknown as React.FormEvent);
            }
          }}
        />
        <div className="flex gap-2 flex-wrap">
          <Button type="submit" disabled={isLoading || !input.trim()}>
            Send Message
          </Button>

          {/* Feedback button â€” only in practice mode and after a few exchanges */}
          {mode === 'practice' && messages.length > 2 && (
            <Button
              type="button"
              variant="outline"
              onClick={handleGetFeedback}
              disabled={isLoading}
            >
              Get Feedback
            </Button>
          )}

          {mode === 'feedback' && (
            <Button
              type="button"
              variant="outline"
              onClick={() => onModeChange('practice')}
            >
              Back to Practice
            </Button>
          )}

          {/* Export button */}
          {messages.length > 1 && (
            <Button
              type="button"
              variant="secondary"
              onClick={handleExport}
              className="ml-auto"
            >
              Export Transcript
            </Button>
          )}
        </div>
      </form>
    </div>
  );
}
